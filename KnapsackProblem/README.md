# knapsack problem

## 基本背包问题(0-1背包问题)

基本背包问题：有N件物品和一个容量为V的背包，放入第i件物品耗费的空间为$C_i$，得到的价值为$W_i$，求解将哪些物品装入背包能使价值总和最大。

关键是写出状态转移函数：$F[i, v] = max\{F[i-1, v], F[i-1, v-C_i]+W_i\}$，时间复杂度为 $O(NV)$，空间复杂度可以优化为$O(V)$，背包问题解决的伪代码为：
```
F[0..V] <- 0
for i <- 1 to N
    for v <- V to Ci
        F[v] <- max{F[v], F[v-Ci]+Wi}
```
将内循环抽象出来可以得到：
```
def ZeroOnePack(F, C, W)
    for v <- V to C
        F[v] <- max(F[v], F[v-C]+W)
```

求最优解的背包问题题目中，事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解，有的题目则并没有必须把背包装满，一种区别这两种问法的实现方法是在初始化的时候有所区别。第一种问法，要求恰好装满背包，那么在初始化时除了F[0]为0，其他F[1..V]均设为-∞；第二种问法，将 F[0..V]都设为0。

## 完全背包问题

完全背包问题：有N种物品和一个容量为V的背包，每种物品都有无限件可能。放入第 i 种物品的费用是 Ci，价值是Wi。求解：将哪些物品装入背包，可以使这些物品的费用总和不超过背包的容量，且价值总和最大。

将完全背包问题转换为01背包问题：最简单的想法是，考虑到第i种物品最多选$\lfloor V/C_i\rfloor$件，于是可以把第i中物品转换为$\lfloor V/C_i \rfloor$件费用及价值均不变的物品，然后求解这个01背包问题。更高的转换方法是将第i种物品拆分成费用为$C_i 2^k$，价值为 $W_i 2^k$ 的若干件物品，其中k取遍满足 $C_i2^k\le V$ 的非负整数。

状态转移函数可以写成：$F(i, v)=max(F(i-1, v-kC_i)+kW_i | 0\le kC_i \le v)$

另一个非常巧妙的解题方法是推导出转移函数为：$F(i, v)=max(F(i-1, v), F(i, v-C_i)+W_i)$，伪代码为：
```
F[0..V] <- 0
for i <- 1..N
    for v <- Ci..V
        F[v] = max(F[v], F[v-Ci]+Wi)
```
和0-1背包问题唯一的不同是内循环的顺序。

## 多重背包问题

有N种物品和一个容量为V的背包。第i种物品最多有Mi件可用，每件耗费的空间为 Ci，价值为Wi，求解将哪些物品装入背包可以使这些物品耗费的空间总和不超过背包容量，且价值总和最大。

$F[i, v]=max(F[i-1, v-kC_i]+kW_i | 0\le k\le min(M_i, \lfloor v/C_i \rfloor))$


